### Министерство науки и высшего образования Российской Федерации

### ТОМСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ СИСТЕМ УПРАВЛЕНИЯ И РАДИОЭЛЕКТРОНИКИ (ТУСУР)

### Кафедра комплексной информационной безопасности электронно-вычислительных систем (КИБЭВС)

### Отчёт по практической работе №5 "БИНАРНЫЕ ДЕРЕВЬЯ ПОИСКА" по дисциплине "Технологии и методы программирования"

Выполнил студент группы 728-1

________Солопов Никита

_____04.2020

Принял

Преподаватель кафедры КИБЭВС

________Перминов П.В.

_____04.2020

Томск 2019

### Введение

Цель работы: целью работы является освоение навыков работы с системой контроля версий gitlab на более высоком уровне. Разработка алгоритма и написание программы, реализующих полноценную работу с бинарным деревом поиска: его создание/очищение, добавление/удаление элементов на разных узлах, а также поиск элементов. Также добавление в дерево функций работы с АВЛ-деревом, то есть, малых правого и левого поворотов.

Описание порядка работы программы:

1. Cоздает пустое дерево, считывает 4 элемента ai, |ai| <= 2147483647 и заносит их в дерево;
2. Выводит дерево (используя функцию print_tree) и пустую строку;
3. Cчитывает 3 элемента ai, |ai| <= 2147483647 и заносит их в дерево;
4. Выводит дерево и пустую строку;
5. Cчитывает m1, |m1| <= 2147483647 и ищет элемент с заданным значением в дереве;
Выводит через пробел значение предка и потомков найденного элемента,
если нет значений предка или потомков вывести "_" вместо таких значений;
Вывести "-", если элемент не найден; Вывести пустую строку;
6. Cчитывает m2, |m2| <= 2147483647 и ищет элемент с заданным значением в дереве;
Выводит через пробел значение предка и потомков найденного элемента,
если нет значений предка или потомков вывести "_" вместо таких значений;
Вывести "-", если элемент не найден; Вывести пустую строку;
7. Считывает m3, |m3| <= 2147483647 и удаляет из дерева элемент с заданным значением (если такой элемент есть);
8. Выводит дерево и пустую строку;
9. Выполняет левый поворот дерева относительно корня, пока это возможно;
10. Выводит дерево и пустую строку; 
11. Выполняет правый поворот дерева относительно корня, пока это возможно;
12. Выводит дерево и пустую строку;
13. Выводит на экран количество элементов в дереве и пустую строку;
14. Очищает дерево;
15. Выводит дерево и пустую строку;

### 1 Теоретическая часть

Бинарное дерево — это иерархическая структура данных, в которой каждый узел имеет значение (оно же является в данном случае и ключом) и ссылки на левого и правого потомка. Узел, находящийся на самом верхнем уровне (не являющийся чьим либо потомком) называется корнем. Узлы, не имеющие потомков (оба потомка которых равны NULL) называются листьями. Бинарное дерево поиска — это бинарное дерево, обладающее дополнительными свойствами: значение левого потомка меньше значения родителя, а значение правого потомка больше значения родителя для каждого узла дерева. То есть, данные в бинарном дереве поиска хранятся в отсортированном виде. При каждой операции вставки нового или удаления существующего узла отсортированный порядок дерева сохраняется. При поиске элемента сравнивается искомое значение с корнем. Если искомое больше корня, то поиск продолжается в правом потомке корня, если меньше, то в левом, если равно, то значение найдено и поиск прекращается. Сбалансированное бинарное дерево поиска — это бинарное дерево поиска с логарифмической высотой. Данное определение скорее идейное, чем строгое. Строгое определение оперирует разницей глубины самого глубокого и самого неглубокого листа (в AVL-деревьях) или отношением глубины самого глубокого и самого неглубокого листа (в красно-черных деревьях). В сбалансированном бинарном дереве поиска операции поиска, вставки и удаления выполняются за логарифмическое время (так как путь к любому листу от корня не более логарифма). В вырожденном случае несбалансированного бинарного дерева поиска, например, когда в пустое дерево вставлялась отсортированная последовательность, дерево превратится в линейный список, и операции поиска, вставки и удаления будут выполняться за линейное время. Поэтому балансировка дерева крайне важна. Технически балансировка осуществляется поворотами частей дерева при вставке нового элемента, если вставка данного элемента нарушила условие сбалансированности. Этот момент также связан и с определением сложностей операций с бинарным деревом. Если дерево сбалансировано, то операции будут происходить быстрее и за меньшее количество действий, в отличие от случая несбалансированного дерева. Самый худший случай--частный, при котором дерево сводится к линейному списку.

Таблица 2.1--Сложности односвязного списка

| Поиск(средн.) | Вставка(средн.) | Удаление(средн.) | Поиск(худш.) | Вставка(худш.) | Удаление(худш.) |
| ------------- | --------------- | ---------------- | ------------ | -------------- | --------------- |
| O(log(n))     | O(log(n))       | O(log(n))        | O(n)         | O(n)           | O(n)            |

### 2 Ход работы

В процессе работы были проделаны следующие действия:

Написаны с помощью программы Visual Studio 2017 программа на основе алгоритма работы с бинарным деревом поиска. Отдельно были прописаны алгоритмы работы, такие как вывод всего дерева в указанном порядке или вставка значения в дерево. Позже функции были написаны и протестированы в вышеупомянутой среде Visual Studio 2017. Ниже продемонстрирована работа двух наиболее простых блоков--создания дерева и вывода внесённых туда элементов.

![](/pr5/images/1.png "1")

Рисунок 2.1--Работа первых блоков программы

Также стоит добавить, что кроме стандартных функций для работы были написаны блоки, реализующие левый и правый малые повороты для АВЛ-дерева. Ниже наглядно продемонстрированы левый и правый повороты в таком дереве. 

![](/pr5/images/2.png "2")

Рисунок 2.2--Балансировка АВЛ-дерева

В рамках темы АВЛ-деревьев существует также и второй способ поворота, показанный ниже.

![](/pr5/images/3.png "3")

Рисунок 2.3--Большой поворот

Необходимо также сказать о структуре двусвязного списка, так как это особенность его работы. Как видно из рисунка ниже, структура состоит из трёх элементов--переменной типа double, в которой хранятся важные данные и двух переменных типа той же структуры(узла дерева), которые потенциально могут предоставлять доступ к последующим элементам, либо не указывать никуда, для этого применяется значение NULL. В объявлении дерева и двусвязного списка есть определённое сходство. При этом приведённую ниже структуру мы можем использовать обоими способами, то есть, только сам программист определяет дальнейший вид конструкции и способы работы с ней.

![](/pr5/images/4.png "4")

Рисунок 2.4--Структура списка(код)

Уже на основе этого была написана работа программы целиком, в которой и использовались блоки-функции.

![](/pr5/images/5.png "5")

Рисунок 2.5--Работа программы

Коды писался с некоторыми добавочными функциями, упрощающими работу с деревом, но не обязательных к применению. Так была написана функция deep(), измеряющая глубину дерева и возвращающая это значение. Также была написана функция all(), возвращающая все узлы. Функции print() и print_tree() согласно практическим соображениям были объединены в одну.

![](/pr5/images/6.png "6")

Рисунок 2.6--Функция нахождения глубины

Также необходимо добавить несколько слов об удалении элементов из дерева. При удалении элемента может возникнуть проблема, что у удалённого элемента были оба потомка, а у них, в свою очередь, есть свои потомки, поэтому удаление может быть сложным для реализации. В таком случае проще всего воспользоваться неким правилом, по которому составляется бинарное дерево поиска: слева--элементы, меньшие корня, а справа, соответственно, большие. Таким образом, удаляя какой-либо элемент мы не нарушая структуру дерева можем заменить удаляемый на самый левый элемент правого поддерева или наоборот--самый правый левого. Ниже приведён пример простейшего удаления элемента.

![](/pr5/images/7.png "7")

Рисунок 2.7--Удаление элемента

В рамках эксперимента был произведён рефакторинг программы по splint, результаты приведены ниже--splint не был успешно пройден из-за некритических ошибок в коде, которые выделяет splint, например, комментарий после include считается как ошибка по неизве тной причине. Стоит отметить, что прохождение по splint необязательно в рамках данной лабораторной работы и поэтому не было выполнено.

![](/pr5/images/8.png "8")

Рисунок 2.8--Рефакторинг по splint

Ниже, в приложении А предоставлен код программы.

В приложении Б можно увидеть ссылки на материалы по CI/CD, GitLab и системе типов Си, использовавшиеся в рамках работы.

### 4 Заключение

В результате работы были закреплены навыки работы с системой контроля версий gitlab на более высоком уровне. Разработан алгоритм, а также написана программа, реализующая полноценную работу с бинарным деревом поиска: его создание/очищение, добавление/удаление элементов на разных узлах, а также поиск элементов.

### Приложение А(код программы)

```с
#include <stdio.h>
#include <malloc.h>
#include <stdbool.h>
struct Tree
{
	struct Tree *Right;
	struct Tree *Left;
	double Data;
};
void init(struct Tree **t)
{
	*t = (struct Tree *)malloc(sizeof(struct Tree));
	(*t)->Right = NULL;
	(*t)->Left = NULL;
	(*t)->Data = 2147483648;
}
void clean(struct Tree *t)
{
	if (t != NULL)
	{
		if (t->Right != NULL)
			clean(t->Right);
		if (t->Left != NULL)
			clean(t->Left);
		free(t);
	}
}
struct Tree* find(struct Tree *t, int value)
{
	if (t->Data==value)
		return t;
	else
	{
		if (value < t->Data)
		{
			if (t->Left != NULL)
				return(find(t->Left, value));
			else
				return NULL;
		}
		else
		{
			if (t->Right != NULL)
				return(find(t->Right, value));
			else
				return NULL;
		}
	}
}
int find_with_output(struct Tree *t, int value)
{
	if (t->Data == value)
	{
		printf("_ ");
		if (t->Left != NULL)
			printf("%d ", (int)t->Left->Data);
		else
			printf("_ ");
		if (t->Right != NULL)
			printf("%d", (int)t->Right->Data);
		else
			printf("_");
	}
	else
	{
		if (value < t->Data)
		{
			if (t->Left != NULL)
			{
				if (t->Left->Data == value)
				{
					printf("%d ", (int)t->Data);
					if ((t->Left->Left) != NULL)
						printf("%d ", (int)t->Left->Left->Data);
					else
						printf("_ ");
					if ((t->Left->Right) != NULL)
						printf("%d", (int)t->Left->Right->Data);
					else
						printf("_");
				}
				else
					return(find_with_output(t->Left, value));
			}
			else
				return 1;
		}
		else
		{
			if (t->Right != NULL)
			{
				if (t->Right->Data == value)
				{
					printf("%d ", (int)t->Data);
					if ((t->Right->Left) != NULL)
						printf("%d ", (int)t->Right->Left->Data);
					else
						printf("_ ");
					if ((t->Right->Right) != NULL)
						printf("%d", (int)t->Right->Right->Data);
					else
						printf("_");
				}
				else
					return(find_with_output(t->Right, value));
			}
			else
				return 1;
		}
	}
	return 0;
}
int insert(struct Tree *t, int value)
{
	if (t->Data == 2147483648)
	{
		t->Data = value;
		return 0;
	}
	if (t->Data == value)
		return 1;
	if (value > (t->Data))
	{
		if ((t->Right)!=NULL)
			return(insert(t->Right, value));
		else
		{
			t->Right=(struct Tree *)malloc(sizeof(struct Tree));
			t->Right->Right = NULL;
			t->Right->Left = NULL;
			t->Right->Data = value;
			return 0;
		}
	}
	else
	{
		if ((t->Left) != NULL)
			return(insert(t->Left, value));
		else
		{
			t->Left = (struct Tree *)malloc(sizeof(struct Tree));
			t->Left->Right = NULL;
			t->Left->Left = NULL;
			t->Left->Data = value;
			return 0;
		}
	}
}
int deep(struct Tree *t)
{
	int r=0, l=0;
	if ((t->Right) != NULL)
		r=deep(t->Right);
	if ((t->Left) != NULL)
		l = deep(t->Left);
	if (r > l)
		return (r+1);
	return (l+1);
}
int remove_node(struct Tree **t, int value)
{
	if ((*t)->Data == value)
	{
		if ((*t)->Right != NULL)
		{
			struct Tree *Temp = (*t)->Right, *Temp2;
			if (Temp->Left != NULL)
			{
				while (Temp->Left->Left != NULL)
					Temp = Temp->Left;
				(*t)->Data = Temp->Left->Data;
				Temp2=Temp->Left;
				Temp->Left=Temp2->Right;
				free(Temp2);
			}
			else
			{
				struct Tree *Temp;
				(*t)->Data = (*t)->Right->Data;
				Temp = (*t)->Right;
				(*t)->Right = (*t)->Right->Right;
				free(Temp);
			}
		}
		else
		{
			struct Tree *Temp;
			Temp = (*t);
			(*t) = (*t)->Left;
			free(Temp);
			Temp = NULL;
		}
		return 0;
	}
	else
	{
		if (value < ((*t)->Data))
		{
			if ((*t)->Left != NULL)
				return(remove_node(&((*t)->Left), value));
			else
				return 1;
		}
		else
		{
			if (((*t)->Right) != NULL)
				return(remove_node(&((*t)->Right), value));
			else
				return 1;
		}
	}
}
int remove_min(struct Tree *t)
{
	struct Tree *Temp = t, *Temp2;
	if (Temp->Left != NULL)
	{
		while (Temp->Left->Left != NULL)
			Temp = Temp->Left;
		Temp2 = Temp->Left;
		Temp->Left = Temp2->Right;
		free(Temp2);
	}
	else
	{
		Temp = t->Right;
		free(t);
		t = Temp;
	}
	return 0;
}
int rotate_right(struct Tree **t)
{
	if (*t == NULL)
		return 1;
	struct Tree *A, *B, *C=(*t)->Right, *x=(*t)->Left, *y=(*t), *Temp = (struct Tree *)malloc(sizeof(struct Tree));
	if (x != NULL)
	{
		A = x->Left;
		B = x->Right;
	}
	else
		return 1;
	Temp->Right = y;
	Temp->Left = A;
	Temp->Right->Right = C;
	Temp->Right->Left = B;
	Temp->Data = x->Data;
	free(x);
	(*t) = Temp;
	return 0;
}
int rotate_left(struct Tree **t)
{
	if (*t == NULL)
		return 1;
	struct Tree *A = (*t)->Left, *B, *C, *x = (*t), *y = (*t)->Right, *Temp=(struct Tree *)malloc(sizeof(struct Tree));
	if (y != NULL)
	{
		B = y->Left;
		C = y->Right;
	}
	else
		return 1;
	Temp->Right = C;
	Temp->Left = x;
	Temp->Left->Right = B;
	Temp->Left->Left = A;
	Temp->Data = y->Data;
	free(y);
	(*t) = Temp;
	return 0;
}
int print_tree(struct Tree *t)
{
	if (t == NULL)
	{
		printf("-\n");
		return 1;
	}
	struct Tree *Temp=t;
	int Rang=0, i, j, k, sk;
	int *comb;
	Rang = deep(t);
	comb = (int*)malloc(sizeof(int));
	for (i = 0; i < Rang; i++)
	{
		if (i != 0)
		{
			comb = (int*)realloc(comb, i* sizeof(int));
			for (j = 0; j < i; j++)
				comb[j] = 0;
		}
		j = 1;
		sk = i;
		while (sk != 0)
		{
			j = j * 2;
			sk--;
		}
		while (j != 0)
		{
			k = 0;
			Temp = t;
			for (k = 0; k < i; k++)
			{
				if (comb[k] == 0)
				{
					if ((Temp->Left) != NULL)
						Temp = Temp->Left;
					else
					{
						k = -1;
						break;
					}
				}
				else
				{
					if ((Temp->Right) != NULL)
						Temp = Temp->Right;
					else
					{
						k = -1;
						break;
					}
				}
			}
			if (i != 0)
			{
				sk=i-1;
				comb[sk]++;
				while (1)
				{
					if (comb[sk] == 2)
					{
						comb[sk] = 0;
						sk--;
						if (sk < 0)
							break;
						else
							comb[sk]++;
					}
					else
						break;
				}
			}
			if (k==-1)
				printf("_");
			else
				printf("%d", (int)Temp->Data);
			j--;
			if (j != 0)
				printf(" ");
		}
		printf("\n");
	}
	return 1;
}
int all(struct Tree *t)
{
	if (t == NULL)
		return 0;
	int r, l;
	l = all(t->Left);
	r = all(t->Right);
	return (l + r+1);
}
int main()
{
	struct Tree *t;
	int i;
	double a;
	init(&t);//1 пункт
	for (i = 0; i < 4; i++)
	{
		scanf("%lf", &a);
		insert(t, a);
	}
	print_tree(t);//2 пункт
	printf("\n");
	for (i = 0; i < 3; i++)//3 пункт
	{
		scanf("%lf", &a);
		insert(t, a);
	}
	print_tree(t);//4 пункт
	printf("\n");
	for (i = 0; i < 2; i++)
	{
		scanf("%lf", &a);//5 и 6 пункт
		a = find_with_output(t, a);
		if (a == 1)
			printf("-");
		printf("\n\n");
	}
	scanf("%lf", &a);//7 пункт
	remove_node(&t, a);
	print_tree(t);//8 пункт
	printf("\n");
	while (1)//9 пункт
	{
		a=rotate_left(&t);
		if (a == 1)
			break;
	}
	print_tree(t);//10 пункт
	printf("\n");
	while (1)//11 пункт
	{
		a = rotate_right(&t);
		if (a == 1)
			break;
	}
	print_tree(t);//12 пункт
	printf("\n");
	printf("%d\n\n", all(t));//13 пункт
	clean(t);//14 пункт
	t = NULL;
	print_tree(t);//15 пункт
	return 0;
}
```

### Приложение Б(ссылки на источники)

* [5 практическая работа. Бинарные деревья поиска](https://gitlab.com/tusur_fb_timp/practices/-/wikis/5-практическая-работа.-Бинарные-деревья-поиска)
* [АВЛ-деревья](https://habr.com/ru/post/150732/)
* [Бинарные деревья поиска](https://habr.com/ru/post/267855/)
* [Балансировка деревьев](https://pandia.ru/text/80/369/88749.php)
* [Структуры данных: бинарные деревья. Часть 1](https://habr.com/ru/post/65617/)