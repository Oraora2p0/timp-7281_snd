### Министерство науки и высшего образования Российской Федерации

### ТОМСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ СИСТЕМ УПРАВЛЕНИЯ И РАДИОЭЛЕКТРОНИКИ (ТУСУР)

### Кафедра комплексной информационной безопасности электронно-вычислительных систем (КИБЭВС)

### Отчёт по практической работе №3 "ОДНОСВЯЗНЫЕ СПИСКИ" по дисциплине "Технологии и методы программирования"

Выполнил студент группы 728-1

________Солопов Никита

_____04.2020

Принял

Преподаватель кафедры КИБЭВС

________Перминов П.В.

_____04.2020

Томск 2019

### Введение

Цель работы: целью работы является освоение навыков работы с системой контроля версий gitlab на более высоком уровне, а конкретно--её взаимодействие с git, возможности загрузки репозитория с компьютера на сайт gitlab. Разработка алгоритма и написание программы, реализующих полноценную работу с линейным списком: его создание/очищение, добавление/удаление элементов на разных узлах, а также поиск элементов.

Описание порядка работы программы:

1. Cчитывает количество элементов n, 0 < n <= 2147483647;
2. Cоздает пустой список, считывает n элементов a, |a| <= 2147483647 и заносит их в список;
3. Выводит содержимое списка, используя функцию print;
4. Считывает k1, k2, k3 (|k| <= 2147483647) и выводит "1", если в списке существует элемент с таким значением и "0", если нет (выводить через пробел, например "1 0 1");
5. Считывает m, |m| <= 2147483647 и вставляет его в конец списка;
6. Выводит содержимое списка, используя функцию print;
7. Считывает t, |t| <= 2147483647 и вставляет его в начало списка;
8. Выводит содержимое списка, используя функцию print;
9. Считывает j и x (0 < j <= 2147483647, |x| <= 2147483647) и вставляет значение x после j-ого элемента списка;
10. Выводит содержимое списка, используя функцию print;
11. Считывает z, |z| <= 2147483647 и удаляет первый элемент (при его наличии), хранящий значение z из списка;
12. Выводит содержимое списка, используя функцию print;
13. Очищает список.

### 1 Теоретическая часть

Основные структуры данных--массивы, стеки, очереди, связанные списки, графы, деревья и хэш-таблицы. Массив — это самая простая и широко используемая структура данных. Другие структуры данных, такие как стеки и очереди, являются производными от массивов. Стек — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»). Подобно стекам, очередь — хранит элемент последовательным образом. Существенное отличие от стека – использование FIFO (First in First Out) вместо LIFO. Граф-это набор узлов (вершин), которые соединены друг с другом в виде сети ребрами (дугами). Дерево-это иерархическая структура данных, состоящая из узлов (вершин) и ребер (дуг). Деревья по сути связанные графы без циклов. Разновидность дерева для строк, быстрый поиск. Хэш-таблицы по факту это массив, в котором ключ представлен в виде хеш-функции. Желательно рассмотреть данные структуры в приведённой ниже таблице:

Таблица 2.1--Основные типы 

| Название типа | Достоинства                                 | Реализация в Си                             |
| ------------- | ------------------------------------------- | ------------------------------------------- |
| Массив        | Равномерный доступ к элементам              | Реализовано                                 |
| Стек          | Использование при отмене действий           | Можно реализовать с помощью структуры       |
| Очередь       | Незаменимость в программах буфера           | Можно реализовать с помощью структуры       |
| Граф          | Незаменимость при работе с путями           | Реализуется с помощью структуры или матрицы |
| Дерево        | Возможность "настройки", мн-во разных видов | Реализуется с помощью структуры             |
| Хэш-таблица   | Множество применений: ассоциативные массивы | Реализуется с помощью массива               |

Для выделения памяти на куче в си используется функция malloc(memory allocation) из библиотеки stdlib.h: void * malloc(size_t size);

Функция выделяет size байтов памяти и возвращает указатель на неё. Если память выделить не удалось, то функция возвращает NULL. Так как malloc возвращает указатель типа void, то его необходимо явно приводить к нужному нам типу.

### 2 Ход работы

В процессе работы были проделаны следующие действия:

Написаны с помощью программы Visual Studio 2017 две программа на основе алгоритма работы с односвязным списком. Отдельно были прописаны алгоритмы работы, такие как вывод всего списка или вставка значения в конец/начало списка. Позже функции были написаны и протестированы в вышеупомянутой среде Visual Studio 2017. Ниже продемонстрирована работа двух наиболее простых блоков--вывода списка целиком и вставки значения в начало списка.

![](/pr3/images/1.png "1")

Рисунок 2.1--Работа блоков программы

Необходимо также сказать о структуре односвязного списка, так как это особенность его работы. Как видно из рисунка ниже, структура состоит из двух элементов--переменной типа double, в которой хранятся важные данные и переменной типа структуры, которая потенциально может предоставлять доступ к последующим элементам списка.

![](/pr3/images/2.png "2")

Рисунок 2.2--Структура списка

Уже на основе этого была написана работа программы целиком, в которой и использовались блоки-функции.

![](/pr3/images/3.png "3")

Рисунок 2.3--Работа программы

Коды писались на основе материалов по работе с односвязанными списками, данными для работы в качестве методички. Отсюда возможно некоторое сходство принципов работы и функционирования. Материалы предоставлены ниже, в приложении А.

![](/pr3/images/4.png "4")

Рисунок 2.4--Возможная реализация добавления в начало

В рамках эксперимента был произведён рефакторинг программы по splint, результаты приведены ниже--splint не был успешно пройден из-за множества недочётов, каждый из которых теоретически можно устранить, но тогда это заняло бы значительный объём времени. Стоит отметить, что прохождение по splint необязательно в рамках данной лабораторной работы и поэтому не было выполнено.

![](/pr3/images/5.png "5")

Рисунок 2.5--Рефакторинг по splint

Также можно добавить, что работа с односвязным списком может быть несовершенной, в качестве улучшения можно переделать структуру программы для работы с двусвязными списками. В таком случае структура узла будет выглядеть уже следующим образом. 

![](/pr3/images/6.png "6")

Рисунок 2.6--Двусвязный список

Для выполнения данной лабораторной работы были  попытки задействованы команды "clone", "add", "сommit", и "push" для загрузки работы на сайт. Ниже приведён результат работы команды clone.

![](/pr3/images/7.png "7")

Рисунок 2.7--Клонированный репозиторий

Ниже, в приложении А предоставлен код программы.

В приложении Б можно увидеть ссылки на материалы по CI/CD, GitLab и системе типов Си, использовавшиеся в рамках работы.

### 4 Заключение

В результате работы были закреплены навыки работы с системой контроля версий gitlab на более высоком уровне, а конкретно--её взаимодействием с git, возможностью загрузки репозитория с компьютера на сайт gitlab. Был Разработан алгоритм, а также написана программа, реализующая полноценную работу с линейным списком, то есть: его создание/очищение, добавление/удаление элементов на разных узлах, а также поиск элементов.

### Приложение А(код программы)

```с
#include <stdio.h>
#include <malloc.h>
#include <stdbool.h>// bool, 
struct List
{
	struct List *NextBlock;
	double Data;
};
struct node
{
	struct node *NextBlock;
	double Data;
};
void init(struct List **l)
{
	*l = (struct List *)malloc(sizeof(struct List));
	(*l)->NextBlock = NULL;
	(*l)->Data = 2147483648;
}
void clean(struct List *l)
{
	struct List *Temp = l;
	do
	{
		Temp = Temp->NextBlock;
		free(l);
		l = Temp;
	} while (l != NULL);
}
bool is_empty(struct List *l)
{
	if (l == NULL)
		return 0;
	else
		return 1;
}
struct node *find(struct List *l, int value)
{
	struct List *Temp = l;
	while (1)
	{
		if (Temp == NULL)
			return NULL;
		else
		{
			if ((Temp->Data) == value)
				return ((struct node *)l);
		}
		Temp = Temp->NextBlock;
	}
}
int push_back(struct List *l, int value)
{
	if (l->Data == 2147483648)
	{
		l->Data = value;
		return 0;
	}
	struct List *Temp = (struct List *)malloc(sizeof(struct List));
	Temp = l;
	while (Temp->NextBlock != NULL)
		Temp = Temp->NextBlock;
	Temp->NextBlock = (struct List *)malloc(sizeof(struct List));
	Temp = Temp->NextBlock;
	Temp->Data = value;
	Temp->NextBlock = NULL;
	return 0;
}
int push_front(struct List **l, int value)
{
	struct List *Temp = (struct List *)malloc(sizeof(struct List));
	Temp->Data = value;
	Temp->NextBlock = (*l);
	(*l) = Temp;
	return 0;
}
int insert_after(struct node *l, int value)
{
	struct List *Temp = (struct List *)malloc(sizeof(struct List)), *Temp2;
	Temp2=(struct List *)l->NextBlock;
	l->NextBlock =(struct node *)Temp;
	Temp->Data = value;
	Temp->NextBlock = Temp2;
	return 0;
}
int remove_node(struct List *l, int value)
{
	struct List *Temp = l;
	if (l != NULL)
	{
		while (1)
		{
			if ((Temp->NextBlock) == NULL)
				return 1;
			if ((Temp->NextBlock->Data) == value)
			{
				struct List *Temp2 = (struct List *)malloc(sizeof(struct List));
				Temp2 = Temp->NextBlock->NextBlock;
				free(Temp->NextBlock);
				Temp->NextBlock = Temp2;
				return 0;
			}
			Temp = Temp->NextBlock;
		}
	}
	else
		return 1;
}
void print(struct List *l)
{
	while (l != NULL)
	{
		printf("%.0lf ", l->Data);
		l = l->NextBlock;
	}
	printf("\n");
}
int main()
{
	struct List *l, *Temp;
	int N, i;
	double a, b;
	scanf("%d", &N);//1
	init(&l);//2 
	for (i = 0; i < N; i++)
	{
		scanf("%lf", &a);
		push_back(l, a);
	}
	print(l);//3
	for (i = 0; i < 3; i++)//4
	{
		scanf("%lf", &a);
		if (find(l, a) == NULL)
			printf("0");
		else
			printf("1");
		if (i!=2)
			printf(" ");
		else
			printf("\n");
	}
	scanf("%lf", &a);//5
	push_back(l, a);
	print(l);//6
	scanf("%lf", &a);//7
	push_front(&l, a);
	print(l);//8
	scanf("%lf", &a);//9
	scanf("%lf", &b);
	struct node *el=(struct node *)l;
	while (a != 1)
	{
		el = el->NextBlock;
		a--;
	}
	insert_after(el, b);
	print(l);//10
	scanf("%lf", &a);//11
	if (l->Data==a)
	{
		Temp=l->NextBlock;
		free(l);
		l=Temp;
	}
	else
		remove_node(l, a);
	print(l);//12
	clean(l);//13
	return 1;
}
```

### Приложение Б(ссылки на источники)

* [Третья практическая работа. Односвязные списки](https://gitlab.com/tusur_fb_timp/practices/-/wikis/3-практическая-работа.-Односвязные-списки)
* [C: cвязанные списки](https://rtfm.co.ua/c-svyazannye-spiski/)
* [Основные структуры данных](https://habr.com/ru/post/422259/)
* [Алгоритмы и структуры данных для начинающих](https://tproger.ru/translations/stacks-and-queues-for-beginners/)
* [Динамическое выделение памяти в С](https://learnc.info/c/memory_allocation.html)